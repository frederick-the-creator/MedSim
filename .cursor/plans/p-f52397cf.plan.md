<!-- f52397cf-0f86-48f5-9765-49298d8c0ba7 e2b9f75b-4820-484b-be29-26cefc2f4a06 -->
# Error Handling + Logging Standard (Pino, Express 5)

## Scope

Project-wide rules for throwing, catching, logging, and responding to errors using `server/middleware/httpLogger.ts`, `server/middleware/errorMiddleware.ts`, and Express 5 async error propagation.

## Goals

- Consistent outcomes: correct HTTP status, safe response body, rich structured logs.
- Zero console noise; only structured logs via Pino.
- Minimal try/catch; let middleware produce both event and summary logs.

## Golden Rules

- Route and service code should not call `console.*`. Use `req.log` (routes) or no logs in services unless a logger is passed in.
- Avoid try/catch in routes/services unless strictly necessary. Let exceptions bubble to `errorMiddleware`.
- Put domain context on the request: set `res.locals.context` in each route, e.g. `{ op: "assessment.generate", conversationId }`.
- Do not log secrets or large payloads. For upstream errors, return 502 with minimal metadata.
- Prefer bubbling provider/library errors; do not wrap upstream errors in custom classes.

## Middleware Order (already correct)

1. `httpLogger` (pino-http) and `startTimer`
2. Routes
3. `errorEventLogger` (domain event log)
4. `errorResponder` (HTTP response + summary log)

## Request Correlation

- `httpLogger` generates/propagates `x-request-id` and binds `req.log`.
- Always use `req.log` in routes. Do not import `logger` except for process boot messages.

## Route Requirements

- Parse/validate input with Zod. On `ZodError`, do not catch; middleware logs and responds 400.
- Immediately set `res.locals.context` with an operation key and lightweight identifiers:
- Minimal shape: `{ op: "feature.operation", ...ids }`.
- Good examples: `{ op: "assessment.generate", conversationId, model: "gemini-2.5-pro" }` or `{ op: "coach.stream", sessionId }`.
- Call services and return results. Do not catch provider/library errors unless adding context and rethrowing.

## Service Rules

- Services should be pure and throw on failure. Do not import Express types into services.
- If a service needs to log, accept an injected logger (e.g., `logger?: Logger`) from the route via `req.log.child({ component: "assessment" })`.
- Services must not throw non-Error values; always throw `Error` or the library's error.

## Error Types and Mapping

- Zod: bubble `ZodError` → middleware logs `issues` (warn) → 400 response with `issues` and `requestId`.
- Google GenAI (`ApiError`): bubble → middleware logs `{ provider: "google-genai", name, status, message(json), stack }` (error) → 502.
- Other upstreams (e.g., ElevenLabs): do not wrap; let errors bubble. Middleware normalizes generic upstream failures to 502 when it can detect provider/status from:
- `err.status` (number) or `err.cause?.status` in 400–599, and/or
- message pattern `"<Provider> error <status>: <statusText>"` (e.g., `"ElevenLabs error 429: Too Many Requests"`), and/or
- `res.locals.context?.provider` if the route set it.
The middleware logs a structured payload `{ provider, name, status, message(parsed), stack, context }` and responds 502.
- Unknown errors: bubble → middleware logs `{ name, message, stack }` (error) → 500.

## Logging Levels

- Summary logs: controlled by `customLogLevel` in `httpLogger` (silent for 2xx/3xx, warn for 4xx, error for 5xx or thrown error).
- Event logs (your own `req.log.*` calls in code or from `errorEventLogger`):
- `info` for notable domain milestones (rare, small payloads only)
- `warn` for client mistakes/validation issues
- `error` for upstream/internal failures

## Sensitive Data Hygiene

- Never log API keys, auth tokens, secrets, or full PII.
- For large texts (e.g., `transcript`, `medicalCase`) log metadata only: lengths, ids, first 100 chars max if absolutely needed.

## Response Policy

- 400: validation problems (Zod); include `issues` and `requestId`.
- 502: upstream API failures; include `provider`, `name`, `status`, `message` (as provided, not the payload), and `reqId`.
- 500: everything else; include `requestId` only.

## Implementation Notes for Middleware

- In `errorEventLogger`:
- Keep existing `ZodError` and `ApiError` branches.
- Add an "upstream generic" detector. Extract `status` from `err.status`/`err.cause?.status` or regex `/^([A-Za-z][\w -]+) error (\d{3}):/` on `err.message`. Infer `provider` from regex group or `res.locals.context?.provider`. If a valid `status` (400–599) is found, log `upstream_api_error` with the structured payload and stash `res.locals.upstreamError = { provider, status, name, message }`.
- In `errorResponder`:
- Before the default 500 branch, check `res.locals.upstreamError` and respond 502 with `{ error: "Upstream API error", ...payload, reqId }`.

## Cleanup Targets Noticed

- Replace `console.log/warn` in `server/features/assessment/services/assessment.ts` with structured logs or remove.
- Optionally set `res.locals.context.provider = 'elevenlabs'` in the route to avoid regex reliance.

## Deliverables

- Expand `.cursor/rules/error-handling.mdc` with this standard (single source of truth).
- Normalize generic upstream failures in `errorMiddleware` to 502 (detection + logging + responder change).
- Set `res.locals.context` consistently in routes (and optionally `.provider`).
- Replace `console.*` in services, wire logger injection where needed.
- Enforce `no-console` and `no-throw-literal` in ESLint.
- Add tests to assert 400/502/500 responses and presence of `requestId`.
- Add short code examples for routes/services in docs.

### To-dos

- [ ] Expand .cursor/rules/error-handling.mdc with full standard
- [ ] Create UpstreamApiError class and extend errorMiddleware to map it to 502
- [ ] Set res.locals.context in assessment and coach routes consistently
- [ ] Replace console.* in services with injected logger or remove
- [ ] Enable no-console and no-throw-literal (and optional no-restricted-syntax) in ESLint
- [ ] Add tests asserting 400/502/500 and requestId presence
- [ ] Add short code examples for routes/services in docs