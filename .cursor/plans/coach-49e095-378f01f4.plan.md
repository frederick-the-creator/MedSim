<!-- 378f01f4-7927-400f-8036-b4239215e5cc 79555713-3d1d-4bcf-9bec-728b95ff786c -->
# Adopt step-based context for Coach flow

### Goal

Use `res.locals.context.step` for operation attribution ("generate" vs "save") and let errors bubble to the central error middleware. Avoid child loggers in this flow.

### Changes

- **Route (`server/features/coach/routes/coach.ts`)**
  - Initialize context once: `{ op: "coach.stream", provider: "google-genai" }`.
  - Before generating, set `res.locals.context.step = "generate"`; call `generateCoachResponse(body)` (no child logger).
  - Stream response as-is; accumulate assistant text.
  - After streaming loop, set `res.locals.context.step = "save"`; `await saveCoachConversation({ conversationId, priorMessages: body.messages, assistantText: acc.trim() })`.
  - Call `res.end()` only after a successful save. If save throws, let it bubble (middleware logs with `step: "save"`).

- **Service (`server/features/coach/services/coach.ts`)**
  - `saveCoachConversation`: remove try/catch so errors bubble. Keep the signature but do not use the logger (prefix as `_logger`), or remove the param if unused elsewhere.
  - `generateCoachResponse`: no change in behavior; do not catch provider errors.

- **Middleware (`server/middleware/errorMiddleware.ts`)**
  - Add `if (res.headersSent) return;` guard at the start of `errorResponder` to avoid writing headers/body after streaming has started. `errorEventLogger` already logs with context.

### Key snippets (concise)

- Route steps
```ts
res.locals.context = { op: "coach.stream", provider: "google-genai" };
res.locals.context.step = "generate";
const response = await generateCoachResponse(body);

let acc = "";
for await (const chunk of response) {
  const text = chunk.text;
  if (text) { res.write(text); acc += text; }
}

res.locals.context.step = "save";
await saveCoachConversation({
  conversationId: "TEST-COACH",
  priorMessages: body.messages,
  assistantText: acc.trim(),
});
res.end();
```

- Save service: bubble errors
```ts
export async function saveCoachConversation(
  input: SaveConverstation,
  _logger?: Logger,
): Promise<void> {
  const { conversationId, priorMessages, assistantText } = input;
  if (!assistantText) return;
  const assistantMsg: CoachMessage = { /* build */ };
  const allMessages = [...priorMessages, assistantMsg];
  await upsertCoachData({ conversationId, messages: allMessages as Json });
}
```

- Error responder guard
```ts
export function errorResponder(err: unknown, req: Request, res: Response, _next: NextFunction): void {
  (res as any).err = err;
  const reqId = req.id;
  if (res.headersSent) return;
  // existing branches (DomainError, ZodError, ApiError, upstream, 500)
}
```


### Notes

- This preserves request-scoped correlation via `req.id` and logs all errors with `{ ...context, step }` in `errorEventLogger`.
- Avoid logging large payloads; no secrets in context.
- If we later want post-response saving, we can reintroduce a local try/catch or a job queue.

### To-dos

- [ ] Set initial context and step before generate/save in coach route
- [ ] Stop passing child logger to generate/save in coach route
- [ ] Remove try/catch from saveCoachConversation; let errors bubble
- [ ] Add res.headersSent guard in errorResponder to avoid writing after streaming
- [ ] Optionally remove unused logger param from generateCoachResponse if not needed