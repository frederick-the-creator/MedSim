// src/errorMiddleware.ts
import { ZodError } from "zod";
import { ApiError } from "@google/genai";
import type { Request, Response, NextFunction } from "express";

export function errorEventLogger(
	err: unknown,
	req: Request,
	res: Response,
	next: NextFunction,
): void {
	// Pino Logger has done the following already:
	// -- It attached a request id (req.id) via your genReqId.
	// -- It attached a per-request logger (req.log) bound to that id.
	// This error middleware will
	// -- Produce event logs
	// ---- These describe what went wrong in domain context (e.g. “This request failed because input validation failed”)
	// ---- This is an application layer log, we can pass it domain information.
	// ---- Log happens when the error occurs
	// ---- Used by analysts for debugging and incident tracing
	// Produce a summary log once response has been sent.
	// ---- This describes how the request performed (e.g. “This request took 42ms and returned 400 for /api/user”)
	// ---- This is a HTTP transport layer log, it doesn't know domain information
	// ---- With customLogLevel, that log level is chosen from the final res.statusCode (e.g., 400→warn, 502/500→error).
	// ---- Log happens at the end of the request
	// ---- Used by DevOps for metrics (e.g. latency, error rates)

	// const reqId = req.id; // Retrive request id (generated by logger)
	// console.log("reqId", reqId);

	// console.log("error");
	// console.log(err);

	// --------- ZOD Error ----------

	if (err instanceof ZodError) {
		// Summarise validation problems into issues
		const issues = err.errors.map((e) => ({
			path: e.path.join("."),
			message: e.message,
		}));

		// Log a structured warn event using pino logger and desired fields
		req.log.warn({ issues }, "zod_validation_failed");
		// Call next(err) to ensure Error object flows to pino (for summary logs) and also pass on to errorResponder middleware
		next(err);
		return;
	}

	// --------- GEMINI ERROR -----------

	if (err instanceof ApiError) {
		// console.log("Recognised as ApiError");
		const name = err.name;
		const status = err.status;

		// Try to parse the message JSON if possible
		let parsedMessage;
		try {
			parsedMessage = JSON.parse(err.message);
		} catch {
			parsedMessage = { raw: err.message };
		}

		// Split stack trace into lines for structured logging
		const stackLines = err.stack
			? err.stack.split("\n").map((line) => line.trim())
			: [];

		const payload = {
			provider: "google-genai",
			name,
			status,
			message: parsedMessage,
			stack: stackLines,
			context: (res as any).locals?.context ?? undefined,
		};
		req.log.error(payload, "gemini_api_error");
		next(err);
		return;
	}

	const ser =
		err instanceof Error
			? { name: err.name, message: err.message, stack: err.stack }
			: { value: err };

	req.log?.error({ error: ser }, "unhandled_error");
	next(err);
}

export function errorResponder(
	err: unknown,
	req: Request,
	res: Response,
	_next: NextFunction,
): void {
	const reqId = req.id;

	if (err instanceof ZodError) {
		const issues = err.errors.map((e) => ({
			path: e.path.join("."),
			message: e.message,
		}));
		res.status(400).json({ error: "Invalid input", issues, requestId: reqId });
		return;
	}

	if (err instanceof ApiError) {
		const name = err.name;
		const status = err.status;
		const message = err.message;
		res.status(502).json({
			// Send final responce of 502, including the json in the 'text' field of the response
			error: "Upstream API error",
			provider: "google-genai",
			name,
			status,
			message,
			reqId,
		});
		return;
	}

	res.status(500).json({ error: "Internal Server Error", requestId: reqId });
}

// TO DO
// Update pino serialiser response object to output assessment so I can validate schema shape
// Update vitest to not suppress logs
// Split error handler and responder - Add next(err) to error handler to make sure pino includes errors in summary logs. Without it, pino will just include req & res
// -- Pino only uses err serialiser for summary if Pino receives the Error object.
// -- If we catch the Error object in the central errorMiddleware, then it has already been caught / handled and doesn't flow to pino
