// src/errorMiddleware.ts
import { ZodError } from "zod";
import { ApiError } from "@google/genai";
import type { Request, Response, NextFunction } from "express";

export function errorMiddleware(
	err: unknown,
	req: Request,
	res: Response,
	_next: NextFunction,
): void {
	// Pino Logger has done the following already:
	// -- It attached a request id (req.id) via your genReqId.
	// -- It attached a per-request logger (req.log) bound to that id.
	// This error middleware will
	// -- Produce event logs
	// ---- These describe what went wrong in domain context (e.g. “This request failed because input validation failed”)
	// ---- This is an application layer log, we can pass it domain information.
	// ---- Log happens when the error occurs
	// ---- Used by analysts for debugging and incident tracing
	// Produce a summary log once response has been sent.
	// ---- This describes how the request performed (e.g. “This request took 42ms and returned 400 for /api/user”)
	// ---- This is a HTTP transport layer log, it doesn't know domain information
	// ---- With customLogLevel, that log level is chosen from the final res.statusCode (e.g., 400→warn, 502/500→error).
	// ---- Log happens at the end of the request
	// ---- Used by DevOps for metrics (e.g. latency, error rates)

	const reqId = req.id; // Retrive request id (generated by logger)
	console.log("reqId", reqId);

	// console.log("error");
	// console.log(err);

	// --------- ZOD Error ----------

	if (err instanceof ZodError) {
		// Summarise validation problems into issues
		const issues = err.errors.map((e) => ({
			path: e.path.join("."),
			message: e.message,
		}));

		// Log a structured warn event using pino logger and desired fields
		req.log.warn(
			{ reqId, issues, route: req.path, method: req.method },
			"zod_validation_failed",
		);

		// Send final responce of 400, including the json in the 'text' field of the response
		// After response, Pino will create summary log using configs such as customLogLevel.
		// Final logging output is two lines of logs, correlaged with reqId
		res.status(400).json({ error: "Invalid input", issues, requestId: reqId });
		return;
	}

	// --------- GEMINI ERROR -----------

	if (err instanceof ApiError) {
		// console.log("Recognised as ApiError");
		const name = err.name;
		const status = err.status;
		const message = err.message;

		const payload = {
			reqId,
			provider: "google-genai",
			name,
			status,
			message,
			stack: err.stack,
			route: req.path,
			method: req.method,
			context: (res as any).locals?.context ?? undefined,
		};
		req.log.error(payload, "gemini_api_error");
		res.status(502).json({
			// Send final responce of 502, including the json in the 'text' field of the response
			error: "Upstream API error",
			provider: "google-genai",
			name,
			status,
			message,
			reqId,
		});
		return;
	}

	// ----------- ALL OTHER ERRORS -------------
	const ser =
		err instanceof Error
			? { name: err.name, message: err.message, stack: err.stack } // If instance of Error, we know how to access properties
			: { value: err }; // If unknonwn instance, just emit entire error object

	req.log?.error(
		{ reqId, route: req.path, method: req.method, error: ser },
		"unhandled_error",
	);
	res.status(500).json({ error: "Internal Server Error", requestId: reqId });
}

// TO DO
// Update pino serialiser response object to output assessment so I can validate schema shape
// Update vitest to not suppress logs
// Split error handler and responder - Add next(err) to error handler to make sure pino includes errors in summary logs. Without it, pino will just include req & res
// -- Pino only uses err serialiser for summary if Pino receives the Error object.
// -- If we catch the Error object in the central errorMiddleware, then it has already been caught / handled and doesn't flow to pino
