// src/errorMiddleware.ts
import { ZodError } from "zod";
import { ApiError } from "@google/genai";
import { DomainError } from "@server/shared/errors";
import type { Request, Response, NextFunction } from "express";

export function errorEventLogger(
	err: unknown,
	req: Request,
	res: Response,
	next: NextFunction,
): void {
	// Pino Logger has done the following already:
	// -- It attached a request id (req.id) via your genReqId.
	// -- It attached a per-request logger (req.log) bound to that id.
	// This error middleware will
	// -- Produce event logs
	// ---- These describe what went wrong in domain context (e.g. “This request failed because input validation failed”)
	// ---- This is an application layer log, we can pass it domain information.
	// ---- Log happens when the error occurs
	// ---- Used by analysts for debugging and incident tracing
	// Produce a summary log once response has been sent.
	// ---- This describes how the request performed (e.g. “This request took 42ms and returned 400 for /api/user”)
	// ---- This is a HTTP transport layer log, it doesn't know domain information
	// ---- With customLogLevel, that log level is chosen from the final res.statusCode (e.g., 400→warn, 502/500→error).
	// ---- Log happens at the end of the request
	// ---- Used by DevOps for metrics (e.g. latency, error rates)

	// const reqId = req.id; // Retrive request id (generated by logger)
	// console.log("reqId", reqId);

	// console.log("error");
	// console.log(err);

	// --------- ZOD Error ----------

	if (err instanceof ZodError) {
		// Summarise validation problems into issues
		const issues = err.errors.map((e) => ({
			path: e.path.join("."),
			message: e.message,
		}));

		// Log a structured warn event using pino logger and desired fields
		req.log.error({ issues }, "zod_validation_failed");
		// Call next(err) to ensure Error object flows to pino (for summary logs) and also pass on to errorResponder middleware
		next(err);
		return;
	}

	// --------- DOMAIN ERROR ---------

	if (err instanceof DomainError) {
		const payload = {
			code: err.code,
			status: err.status,
			details: err.details,
			context: (res as any).locals?.context ?? undefined,
		};
		req.log.error(payload, "domain_error");
		next(err);
		return;
	}

	// --------- GEMINI ERROR -----------

	if (err instanceof ApiError) {
		// console.log("Recognised as ApiError");
		const name = err.name;
		const status = err.status;

		// Try to parse the message JSON if possible
		let parsedMessage;
		try {
			parsedMessage = JSON.parse(err.message);
		} catch {
			parsedMessage = { raw: err.message };
		}

		// Split stack trace into lines for structured logging
		const stackLines = err.stack
			? err.stack.split("\n").map((line) => line.trim())
			: [];

		const payload = {
			provider: "google-genai",
			name,
			status,
			message: parsedMessage,
			stack: stackLines,
			context: (res as any).locals?.context ?? undefined,
		};
		req.log.error(payload, "gemini_api_error");
		next(err);
		return;
	}

	// --------- GENERIC UPSTREAM (e.g., fetch/HTTP libraries) -----------

	// Try to detect upstream provider + status without wrapping errors
	if (err && typeof err === "object") {
		const anyErr = err as any;
		const name: string = anyErr.name || "Error";
		const rawMessage: string =
			typeof anyErr.message === "string"
				? anyErr.message
				: String(anyErr.message ?? "");
		const statusFromFields: number | undefined =
			typeof anyErr.status === "number"
				? anyErr.status
				: typeof anyErr.cause?.status === "number"
					? anyErr.cause.status
					: undefined;

		// Message pattern: "<Provider> error <status>: <statusText>"
		const msgMatch =
			typeof rawMessage === "string"
				? /^([A-Za-z][\w -]+) error (\d{3}):/.exec(rawMessage)
				: null;
		const statusFromMsg = msgMatch ? Number(msgMatch[2]) : undefined;
		const providerFromMsg = msgMatch
			? msgMatch[1]?.toLowerCase().replace(/\s+/g, "-")
			: undefined;
		const status: number | undefined = statusFromFields ?? statusFromMsg;

		if (typeof status === "number" && status >= 400 && status <= 599) {
			const provider =
				providerFromMsg || (res as any).locals?.context?.provider || "upstream";
			const stackLines = anyErr.stack
				? String(anyErr.stack)
						.split("\n")
						.map((l: string) => l.trim())
				: [];
			const payload = {
				provider,
				name,
				status,
				message: rawMessage,
				stack: stackLines,
				context: (res as any).locals?.context ?? undefined,
			};
			req.log.error(payload, "upstream_api_error");
			(res as any).locals = (res as any).locals || {};
			(res as any).locals.upstreamError = {
				provider,
				name,
				status,
				message: rawMessage,
			};
			next(err);
			return;
		}
	}

	const ser =
		err instanceof Error
			? { name: err.name, message: err.message, stack: err.stack }
			: { value: err };

	req.log?.error({ error: ser }, "unhandled_error");
	next(err);
}

export function errorResponder(
	err: unknown,
	req: Request,
	res: Response,
	_next: NextFunction,
): void {
	(res as any).err = err; // <-- make the error visible to pino-http
	const reqId = req.id;
	if (res.headersSent) {
		// Response already sent; avoid attempting to write headers/body
		return;
	}

	if (err instanceof DomainError) {
		const details = (err as DomainError).details as any | undefined;
		if (details?.retryAfterSecs != null) {
			res.setHeader("Retry-After", String(details.retryAfterSecs));
		}
		res.status((err as DomainError).status).json({
			error: "Domain error",
			code: (err as DomainError).code,
			message: (err as DomainError).message,
			...(details ? { details } : {}),
			requestId: reqId,
		});
		return;
	}

	if (err instanceof ZodError) {
		const issues = err.errors.map((e) => ({
			path: e.path.join("."),
			message: e.message,
		}));
		res.status(400).json({ error: "Invalid input", issues, requestId: reqId });
		return;
	}

	if (err instanceof ApiError) {
		const name = err.name;
		const status = err.status;
		const message = err.message;
		res.status(502).json({
			// Send final responce of 502, including the json in the 'text' field of the response
			error: "Upstream API error",
			provider: "google-genai",
			name,
			status,
			message,
			reqId,
		});
		return;
	}

	// If a generic upstream error was detected in errorEventLogger, respond as 502
	const upstream = (res as any).locals?.upstreamError as
		| { provider: string; name: string; status: number; message: string }
		| undefined;
	if (upstream) {
		res.status(502).json({
			error: "Upstream API error",
			provider: upstream.provider,
			name: upstream.name,
			status: upstream.status,
			message: upstream.message,
			reqId,
		});
		return;
	}

	res.status(500).json({ error: "Internal Server Error", requestId: reqId });
}

// TO DO
// Update pino serialiser response object to output assessment so I can validate schema shape
// Update vitest to not suppress logs
// Split error handler and responder - Add next(err) to error handler to make sure pino includes errors in summary logs. Without it, pino will just include req & res
// -- Pino only uses err serialiser for summary if Pino receives the Error object.
// -- If we catch the Error object in the central errorMiddleware, then it has already been caught / handled and doesn't flow to pino
